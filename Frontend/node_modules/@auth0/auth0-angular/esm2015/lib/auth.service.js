import { Injectable, Inject } from '@angular/core';
import { Auth0Client, } from '@auth0/auth0-spa-js';
import { of, from, Subject, iif, defer, ReplaySubject, throwError, } from 'rxjs';
import { concatMap, tap, map, takeUntil, catchError, switchMap, withLatestFrom, } from 'rxjs/operators';
import { Auth0ClientService } from './auth.client';
import { AbstractNavigator } from './abstract-navigator';
import { AuthClientConfig, } from './auth.config';
import { AuthState } from './auth.state';
import * as i0 from "@angular/core";
import * as i1 from "./auth.client";
import * as i2 from "./auth.config";
import * as i3 from "./abstract-navigator";
import * as i4 from "./auth.state";
export class AuthService {
    constructor(auth0Client, configFactory, navigator, authState) {
        this.auth0Client = auth0Client;
        this.configFactory = configFactory;
        this.navigator = navigator;
        this.authState = authState;
        this.appStateSubject$ = new ReplaySubject(1);
        // https://stackoverflow.com/a/41177163
        this.ngUnsubscribe$ = new Subject();
        /**
         * Emits boolean values indicating the loading state of the SDK.
         */
        this.isLoading$ = this.authState.isLoading$;
        /**
         * Emits boolean values indicating the authentication state of the user. If `true`, it means a user has authenticated.
         * This depends on the value of `isLoading$`, so there is no need to manually check the loading state of the SDK.
         */
        this.isAuthenticated$ = this.authState.isAuthenticated$;
        /**
         * Emits details about the authenticated user, or null if not authenticated.
         */
        this.user$ = this.authState.user$;
        /**
         * Emits ID token claims when authenticated, or null if not authenticated.
         */
        this.idTokenClaims$ = this.authState.idTokenClaims$;
        /**
         * Emits errors that occur during login, or when checking for an active session on startup.
         */
        this.error$ = this.authState.error$;
        /**
         * Emits the value (if any) that was passed to the `loginWithRedirect` method call
         * but only **after** `handleRedirectCallback` is first called
         */
        this.appState$ = this.appStateSubject$.asObservable();
        const checkSessionOrCallback$ = (isCallback) => iif(() => isCallback, this.handleRedirectCallback(), defer(() => this.auth0Client.checkSession()));
        this.shouldHandleCallback()
            .pipe(switchMap((isCallback) => checkSessionOrCallback$(isCallback).pipe(catchError((error) => {
            const config = this.configFactory.get();
            this.authState.setError(error);
            this.navigator.navigateByUrl(config.errorPath || '/');
            return of(undefined);
        }))), tap(() => {
            this.authState.setIsLoading(false);
        }), takeUntil(this.ngUnsubscribe$))
            .subscribe();
    }
    /**
     * Called when the service is destroyed
     */
    ngOnDestroy() {
        // https://stackoverflow.com/a/41177163
        this.ngUnsubscribe$.next();
        this.ngUnsubscribe$.complete();
    }
    /**
     * ```js
     * loginWithRedirect(options);
     * ```
     *
     * Performs a redirect to `/authorize` using the parameters
     * provided as arguments. Random and secure `state` and `nonce`
     * parameters will be auto-generated.
     *
     * @param options The login options
     */
    loginWithRedirect(options) {
        return from(this.auth0Client.loginWithRedirect(options));
    }
    /**
     * ```js
     * await loginWithPopup(options);
     * ```
     *
     * Opens a popup with the `/authorize` URL using the parameters
     * provided as arguments. Random and secure `state` and `nonce`
     * parameters will be auto-generated. If the response is successful,
     * results will be valid according to their expiration times.
     *
     * IMPORTANT: This method has to be called from an event handler
     * that was started by the user like a button click, for example,
     * otherwise the popup will be blocked in most browsers.
     *
     * @param options The login options
     * @param config Configuration for the popup window
     */
    loginWithPopup(options, config) {
        return from(this.auth0Client.loginWithPopup(options, config).then(() => {
            this.authState.refresh();
        }));
    }
    /**
     * ```js
     * logout();
     * ```
     *
     * Clears the application session and performs a redirect to `/v2/logout`, using
     * the parameters provided as arguments, to clear the Auth0 session.
     * If the `federated` option is specified it also clears the Identity Provider session.
     * If the `localOnly` option is specified, it only clears the application session.
     * It is invalid to set both the `federated` and `localOnly` options to `true`,
     * and an error will be thrown if you do.
     * [Read more about how Logout works at Auth0](https://auth0.com/docs/logout).
     *
     * @param options The logout options
     */
    logout(options) {
        const logout = this.auth0Client.logout(options) || of(null);
        from(logout).subscribe(() => {
            if (options === null || options === void 0 ? void 0 : options.localOnly) {
                this.authState.refresh();
            }
        });
    }
    /**
     * ```js
     * getAccessTokenSilently(options).subscribe(token => ...)
     * ```
     *
     * If there's a valid token stored, return it. Otherwise, opens an
     * iframe with the `/authorize` URL using the parameters provided
     * as arguments. Random and secure `state` and `nonce` parameters
     * will be auto-generated. If the response is successful, results
     * will be valid according to their expiration times.
     *
     * If refresh tokens are used, the token endpoint is called directly with the
     * 'refresh_token' grant. If no refresh token is available to make this call,
     * the SDK falls back to using an iframe to the '/authorize' URL.
     *
     * This method may use a web worker to perform the token call if the in-memory
     * cache is used.
     *
     * If an `audience` value is given to this function, the SDK always falls
     * back to using an iframe to make the token exchange.
     *
     * Note that in all cases, falling back to an iframe requires access to
     * the `auth0` cookie, and thus will not work in browsers that block third-party
     * cookies by default (Safari, Brave, etc).
     *
     * @param options The options for configuring the token fetch.
     */
    getAccessTokenSilently(options = {}) {
        return of(this.auth0Client).pipe(concatMap((client) => options.detailedResponse === true
            ? client.getTokenSilently(Object.assign(Object.assign({}, options), { detailedResponse: true }))
            : client.getTokenSilently(options)), tap((token) => this.authState.setAccessToken(typeof token === 'string' ? token : token.access_token)), catchError((error) => {
            this.authState.setError(error);
            this.authState.refresh();
            return throwError(error);
        }));
    }
    /**
     * ```js
     * getTokenWithPopup(options).subscribe(token => ...)
     * ```
     *
     * Get an access token interactively.
     *
     * Opens a popup with the `/authorize` URL using the parameters
     * provided as arguments. Random and secure `state` and `nonce`
     * parameters will be auto-generated. If the response is successful,
     * results will be valid according to their expiration times.
     */
    getAccessTokenWithPopup(options) {
        return of(this.auth0Client).pipe(concatMap((client) => client.getTokenWithPopup(options)), tap((token) => this.authState.setAccessToken(token)), catchError((error) => {
            this.authState.setError(error);
            this.authState.refresh();
            return throwError(error);
        }));
    }
    /**
     * ```js
     * handleRedirectCallback(url).subscribe(result => ...)
     * ```
     *
     * After the browser redirects back to the callback page,
     * call `handleRedirectCallback` to handle success and error
     * responses from Auth0. If the response is successful, results
     * will be valid according to their expiration times.
     *
     * Calling this method also refreshes the authentication and user states.
     *
     * @param url The URL to that should be used to retrieve the `state` and `code` values. Defaults to `window.location.href` if not given.
     */
    handleRedirectCallback(url) {
        return defer(() => this.auth0Client.handleRedirectCallback(url)).pipe(withLatestFrom(this.authState.isLoading$), tap(([result, isLoading]) => {
            var _a;
            if (!isLoading) {
                this.authState.refresh();
            }
            const appState = result === null || result === void 0 ? void 0 : result.appState;
            const target = (_a = appState === null || appState === void 0 ? void 0 : appState.target) !== null && _a !== void 0 ? _a : '/';
            if (appState) {
                this.appStateSubject$.next(appState);
            }
            this.navigator.navigateByUrl(target);
        }), map(([result]) => result));
    }
    /**
     * ```js
     * buildAuthorizeUrl().subscribe(url => ...)
     * ```
     *
     * Builds an `/authorize` URL for loginWithRedirect using the parameters
     * provided as arguments. Random and secure `state` and `nonce`
     * parameters will be auto-generated.
     * @param options The options
     * @returns A URL to the authorize endpoint
     */
    buildAuthorizeUrl(options) {
        return defer(() => this.auth0Client.buildAuthorizeUrl(options));
    }
    /**
     * ```js
     * buildLogoutUrl().subscribe(url => ...)
     * ```
     * Builds a URL to the logout endpoint.
     *
     * @param options The options used to configure the parameters that appear in the logout endpoint URL.
     * @returns a URL to the logout endpoint using the parameters provided as arguments.
     */
    buildLogoutUrl(options) {
        return of(this.auth0Client.buildLogoutUrl(options));
    }
    shouldHandleCallback() {
        return of(location.search).pipe(map((search) => {
            return ((search.includes('code=') || search.includes('error=')) &&
                search.includes('state=') &&
                !this.configFactory.get().skipRedirectCallback);
        }));
    }
}
AuthService.ɵprov = i0.ɵɵdefineInjectable({ factory: function AuthService_Factory() { return new AuthService(i0.ɵɵinject(i1.Auth0ClientService), i0.ɵɵinject(i2.AuthClientConfig), i0.ɵɵinject(i3.AbstractNavigator), i0.ɵɵinject(i4.AuthState)); }, token: AuthService, providedIn: "root" });
AuthService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
AuthService.ctorParameters = () => [
    { type: Auth0Client, decorators: [{ type: Inject, args: [Auth0ClientService,] }] },
    { type: AuthClientConfig },
    { type: AbstractNavigator },
    { type: AuthState }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXV0aC5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vcHJvamVjdHMvYXV0aDAtYW5ndWxhci9zcmMvbGliL2F1dGguc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sRUFBYSxNQUFNLGVBQWUsQ0FBQztBQUU5RCxPQUFPLEVBQ0wsV0FBVyxHQVVaLE1BQU0scUJBQXFCLENBQUM7QUFFN0IsT0FBTyxFQUNMLEVBQUUsRUFDRixJQUFJLEVBQ0osT0FBTyxFQUVQLEdBQUcsRUFDSCxLQUFLLEVBQ0wsYUFBYSxFQUNiLFVBQVUsR0FDWCxNQUFNLE1BQU0sQ0FBQztBQUVkLE9BQU8sRUFDTCxTQUFTLEVBQ1QsR0FBRyxFQUNILEdBQUcsRUFDSCxTQUFTLEVBQ1QsVUFBVSxFQUNWLFNBQVMsRUFDVCxjQUFjLEdBQ2YsTUFBTSxnQkFBZ0IsQ0FBQztBQUV4QixPQUFPLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDbkQsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sc0JBQXNCLENBQUM7QUFDekQsT0FBTyxFQUNMLGdCQUFnQixHQUVqQixNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sY0FBYyxDQUFDOzs7Ozs7QUFLekMsTUFBTSxPQUFPLFdBQVc7SUFxQ3RCLFlBQ3NDLFdBQXdCLEVBQ3BELGFBQStCLEVBQy9CLFNBQTRCLEVBQzVCLFNBQW9CO1FBSFEsZ0JBQVcsR0FBWCxXQUFXLENBQWE7UUFDcEQsa0JBQWEsR0FBYixhQUFhLENBQWtCO1FBQy9CLGNBQVMsR0FBVCxTQUFTLENBQW1CO1FBQzVCLGNBQVMsR0FBVCxTQUFTLENBQVc7UUF4Q3RCLHFCQUFnQixHQUFHLElBQUksYUFBYSxDQUFZLENBQUMsQ0FBQyxDQUFDO1FBRTNELHVDQUF1QztRQUMvQixtQkFBYyxHQUFHLElBQUksT0FBTyxFQUFR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UUFDdkMsQ0FBQyxDQUFDLEVBQ0YsR0FBRyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFFLENBQUMsTUFBTSxDQUFDLENBQzFCLENBQUM7SUFDSixDQUFDO0lBRUQ7Ozs7Ozs7Ozs7T0FVRztJQUNILGlCQUFpQixDQUFDLE9BQThCO1FBQzlDLE9BQU8sS0FBSyxDQUFDLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsaUJBQWlCLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQztJQUNsRSxDQUFDO0lBRUQ7Ozs7Ozs7O09BUUc7SUFDSCxjQUFjLENBQUMsT0FBMEI7UUFDdkMsT0FBTyxFQUFFLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxjQUFjLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQztJQUN0RCxDQUFDO0lBRU8sb0JBQW9CO1FBQzFCLE9BQU8sRUFBRSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxJQUFJLENBQzdCLEdBQUcsQ0FBQyxDQUFDLE1BQU0sRUFBRSxFQUFFO1lBQ2IsT0FBTyxDQUNMLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsSUFBSSxNQUFNLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxDQUFDO2dCQUN2RCxNQUFNLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQztnQkFDekIsQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLEdBQUcsRUFBRSxDQUFDLG9CQUFvQixDQUMvQyxDQUFDO1FBQ0osQ0FBQyxDQUFDLENBQ0gsQ0FBQztJQUNKLENBQUM7Ozs7WUF6VEYsVUFBVSxTQUFDO2dCQUNWLFVBQVUsRUFBRSxNQUFNO2FBQ25COzs7WUEzQ0MsV0FBVyx1QkFrRlIsTUFBTSxTQUFDLGtCQUFrQjtZQTlDNUIsZ0JBQWdCO1lBRlQsaUJBQWlCO1lBS2pCLFNBQVMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlLCBJbmplY3QsIE9uRGVzdHJveSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQge1xuICBBdXRoMENsaWVudCxcbiAgUmVkaXJlY3RMb2dpbk9wdGlvbnMsXG4gIFBvcHVwTG9naW5PcHRpb25zLFxuICBQb3B1cENvbmZpZ09wdGlvbnMsXG4gIExvZ291dE9wdGlvbnMsXG4gIEdldFRva2VuU2lsZW50bHlPcHRpb25zLFxuICBHZXRUb2tlbldpdGhQb3B1cE9wdGlvbnMsXG4gIFJlZGlyZWN0TG9naW5SZXN1bHQsXG4gIExvZ291dFVybE9wdGlvbnMsXG4gIEdldFRva2VuU2lsZW50bHlWZXJib3NlUmVzcG9uc2UsXG59IGZyb20gJ0BhdXRoMC9hdXRoMC1zcGEtanMnO1xuXG5pbXBvcnQge1xuICBvZixcbiAgZnJvbSxcbiAgU3ViamVjdCxcbiAgT2JzZXJ2YWJsZSxcbiAgaWlmLFxuICBkZWZlcixcbiAgUmVwbGF5U3ViamVjdCxcbiAgdGhyb3dFcnJvcixcbn0gZnJvbSAncnhqcyc7XG5cbmltcG9ydCB7XG4gIGNvbmNhdE1hcCxcbiAgdGFwLFxuICBtYXAsXG4gIHRha2VVbnRpbCxcbiAgY2F0Y2hFcnJvcixcbiAgc3dpdGNoTWFwLFxuICB3aXRoTGF0ZXN0RnJvbSxcbn0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5pbXBvcnQgeyBBdXRoMENsaWVudFNlcnZpY2UgfSBmcm9tICcuL2F1dGguY2xpZW50JztcbmltcG9ydCB7IEFic3RyYWN0TmF2aWdhdG9yIH0gZnJvbSAnLi9hYnN0cmFjdC1uYXZpZ2F0b3InO1xuaW1wb3J0IHtcbiAgQXV0aENsaWVudENvbmZpZyxcbiAgQXBwU3RhdGUsXG59IGZyb20gJy4vYXV0aC5jb25maWcnO1xuaW1wb3J0IHsgQXV0aFN0YXRlIH0gZnJvbSAnLi9hdXRoLnN0YXRlJztcblxuQEluamVjdGFibGUoe1xuICBwcm92aWRlZEluOiAncm9vdCcsXG59KVxuZXhwb3J0IGNsYXNzIEF1dGhTZXJ2aWNlPFRBcHBTdGF0ZSBleHRlbmRzIEFwcFN0YXRlID0gQXBwU3RhdGU+IGltcGxlbWVudHMgT25EZXN0cm95IHtcbiAgcHJpdmF0ZSBhcHBTdGF0ZVN1YmplY3QkID0gbmV3IFJlcGxheVN1YmplY3Q8VEFwcFN0YXRlPigxKTtcblxuICAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNDExNzcxNjNcbiAgcHJpdmF0ZSBuZ1Vuc3Vic2NyaWJlJCA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG4gIC8qKlxuICAgKiBFbWl0cyBib29sZWFuIHZhbHVlcyBpbmRpY2F0aW5nIHRoZSBsb2FkaW5nIHN0YXRlIG9mIHRoZSBTREsuXG4gICAqL1xuICByZWFkb25seSBpc0xvYWRpbmckID0gdGhpcy5hdXRoU3RhdGUuaXNMb2FkaW5nJDtcblxuICAvKipcbiAgICogRW1pdHMgYm9vbGVhbiB2YWx1ZXMgaW5kaWNhdGluZyB0aGUgYXV0aGVudGljYXRpb24gc3RhdGUgb2YgdGhlIHVzZXIuIElmIGB0cnVlYCwgaXQgbWVhbnMgYSB1c2VyIGhhcyBhdXRoZW50aWNhdGVkLlxuICAgKiBUaGlzIGRlcGVuZHMgb24gdGhlIHZhbHVlIG9mIGBpc0xvYWRpbmckYCwgc28gdGhlcmUgaXMgbm8gbmVlZCB0byBtYW51YWxseSBjaGVjayB0aGUgbG9hZGluZyBzdGF0ZSBvZiB0aGUgU0RLLlxuICAgKi9cbiAgcmVhZG9ubHkgaXNBdXRoZW50aWNhdGVkJCA9IHRoaXMuYXV0aFN0YXRlLmlzQXV0aGVudGljYXRlZCQ7XG5cbiAgLyoqXG4gICAqIEVtaXRzIGRldGFpbHMgYWJvdXQgdGhlIGF1dGhlbnRpY2F0ZWQgdXNlciwgb3IgbnVsbCBpZiBub3QgYXV0aGVudGljYXRlZC5cbiAgICovXG4gIHJlYWRvbmx5IHVzZXIkID0gdGhpcy5hdXRoU3RhdGUudXNlciQ7XG5cbiAgLyoqXG4gICAqIEVtaXRzIElEIHRva2VuIGNsYWltcyB3aGVuIGF1dGhlbnRpY2F0ZWQsIG9yIG51bGwgaWYgbm90IGF1dGhlbnRpY2F0ZWQuXG4gICAqL1xuICByZWFkb25seSBpZFRva2VuQ2xhaW1zJCA9IHRoaXMuYXV0aFN0YXRlLmlkVG9rZW5DbGFpbXMkO1xuXG4gIC8qKlxuICAgKiBFbWl0cyBlcnJvcnMgdGhhdCBvY2N1ciBkdXJpbmcgbG9naW4sIG9yIHdoZW4gY2hlY2tpbmcgZm9yIGFuIGFjdGl2ZSBzZXNzaW9uIG9uIHN0YXJ0dXAuXG4gICAqL1xuICByZWFkb25seSBlcnJvciQgPSB0aGlzLmF1dGhTdGF0ZS5lcnJvciQ7XG5cbiAgLyoqXG4gICAqIEVtaXRzIHRoZSB2YWx1ZSAoaWYgYW55KSB0aGF0IHdhcyBwYXNzZWQgdG8gdGhlIGBsb2dpbldpdGhSZWRpcmVjdGAgbWV0aG9kIGNhbGxcbiAgICogYnV0IG9ubHkgKiphZnRlcioqIGBoYW5kbGVSZWRpcmVjdENhbGxiYWNrYCBpcyBmaXJzdCBjYWxsZWRcbiAgICovXG4gIHJlYWRvbmx5IGFwcFN0YXRlJCA9IHRoaXMuYXBwU3RhdGVTdWJqZWN0JC5hc09ic2VydmFibGUoKTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBASW5qZWN0KEF1dGgwQ2xpZW50U2VydmljZSkgcHJpdmF0ZSBhdXRoMENsaWVudDogQXV0aDBDbGllbnQsXG4gICAgcHJpdmF0ZSBjb25maWdGYWN0b3J5OiBBdXRoQ2xpZW50Q29uZmlnLFxuICAgIHByaXZhdGUgbmF2aWdhdG9yOiBBYnN0cmFjdE5hdmlnYXRvcixcbiAgICBwcml2YXRlIGF1dGhTdGF0ZTogQXV0aFN0YXRlXG4gICkge1xuICAgIGNvbnN0IGNoZWNrU2Vzc2lvbk9yQ2FsbGJhY2skID0gKGlzQ2FsbGJhY2s6IGJvb2xlYW4pID0+XG4gICAgICBpaWYoXG4gICAgICAgICgpID0+IGlzQ2FsbGJhY2ssXG4gICAgICAgIHRoaXMuaGFuZGxlUmVkaXJlY3RDYWxsYmFjaygpLFxuICAgICAgICBkZWZlcigoKSA9PiB0aGlzLmF1dGgwQ2xpZW50LmNoZWNrU2Vzc2lvbigpKVxuICAgICAgKTtcblxuICAgIHRoaXMuc2hvdWxkSGFuZGxlQ2FsbGJhY2soKVxuICAgICAgLnBpcGUoXG4gICAgICAgIHN3aXRjaE1hcCgoaXNDYWxsYmFjaykgPT5cbiAgICAgICAgICBjaGVja1Nlc3Npb25PckNhbGxiYWNrJChpc0NhbGxiYWNrKS5waXBlKFxuICAgICAgICAgICAgY2F0Y2hFcnJvcigoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgY29uZmlnID0gdGhpcy5jb25maWdGYWN0b3J5LmdldCgpO1xuICAgICAgICAgICAgICB0aGlzLmF1dGhTdGF0ZS5zZXRFcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgIHRoaXMubmF2aWdhdG9yLm5hdmlnYXRlQnlVcmwoY29uZmlnLmVycm9yUGF0aCB8fCAnLycpO1xuICAgICAgICAgICAgICByZXR1cm4gb2YodW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKVxuICAgICAgICApLFxuICAgICAgICB0YXAoKCkgPT4ge1xuICAgICAgICAgIHRoaXMuYXV0aFN0YXRlLnNldElzTG9hZGluZyhmYWxzZSk7XG4gICAgICAgIH0pLFxuICAgICAgICB0YWtlVW50aWwodGhpcy5uZ1Vuc3Vic2NyaWJlJClcbiAgICAgIClcbiAgICAgIC5zdWJzY3JpYmUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiB0aGUgc2VydmljZSBpcyBkZXN0cm95ZWRcbiAgICovXG4gIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS80MTE3NzE2M1xuICAgIHRoaXMubmdVbnN1YnNjcmliZSQubmV4dCgpO1xuICAgIHRoaXMubmdVbnN1YnNjcmliZSQuY29tcGxldGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBgYGBqc1xuICAgKiBsb2dpbldpdGhSZWRpcmVjdChvcHRpb25zKTtcbiAgICogYGBgXG4gICAqXG4gICAqIFBlcmZvcm1zIGEgcmVkaXJlY3QgdG8gYC9hdXRob3JpemVgIHVzaW5nIHRoZSBwYXJhbWV0ZXJzXG4gICAqIHByb3ZpZGVkIGFzIGFyZ3VtZW50cy4gUmFuZG9tIGFuZCBzZWN1cmUgYHN0YXRlYCBhbmQgYG5vbmNlYFxuICAgKiBwYXJhbWV0ZXJzIHdpbGwgYmUgYXV0by1nZW5lcmF0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zIFRoZSBsb2dpbiBvcHRpb25zXG4gICAqL1xuICBsb2dpbldpdGhSZWRpcmVjdChvcHRpb25zPzogUmVkaXJlY3RMb2dpbk9wdGlvbnM8VEFwcFN0YXRlPik6IE9ic2VydmFibGU8dm9pZD4ge1xuICAgIHJldHVybiBmcm9tKHRoaXMuYXV0aDBDbGllbnQubG9naW5XaXRoUmVkaXJlY3Qob3B0aW9ucykpO1xuICB9XG5cbiAgLyoqXG4gICAqIGBgYGpzXG4gICAqIGF3YWl0IGxvZ2luV2l0aFBvcHVwKG9wdGlvbnMpO1xuICAgKiBgYGBcbiAgICpcbiAgICogT3BlbnMgYSBwb3B1cCB3aXRoIHRoZSBgL2F1dGhvcml6ZWAgVVJMIHVzaW5nIHRoZSBwYXJhbWV0ZXJzXG4gICAqIHByb3ZpZGVkIGFzIGFyZ3VtZW50cy4gUmFuZG9tIGFuZCBzZWN1cmUgYHN0YXRlYCBhbmQgYG5vbmNlYFxuICAgKiBwYXJhbWV0ZXJzIHdpbGwgYmUgYXV0by1nZW5lcmF0ZWQuIElmIHRoZSByZXNwb25zZSBpcyBzdWNjZXNzZnVsLFxuICAgKiByZXN1bHRzIHdpbGwgYmUgdmFsaWQgYWNjb3JkaW5nIHRvIHRoZWlyIGV4cGlyYXRpb24gdGltZXMuXG4gICAqXG4gICAqIElNUE9SVEFOVDogVGhpcyBtZXRob2QgaGFzIHRvIGJlIGNhbGxlZCBmcm9tIGFuIGV2ZW50IGhhbmRsZXJcbiAgICogdGhhdCB3YXMgc3RhcnRlZCBieSB0aGUgdXNlciBsaWtlIGEgYnV0dG9uIGNsaWNrLCBmb3IgZXhhbXBsZSxcbiAgICogb3RoZXJ3aXNlIHRoZSBwb3B1cCB3aWxsIGJlIGJsb2NrZWQgaW4gbW9zdCBicm93c2Vycy5cbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMgVGhlIGxvZ2luIG9wdGlvbnNcbiAgICogQHBhcmFtIGNvbmZpZyBDb25maWd1cmF0aW9uIGZvciB0aGUgcG9wdXAgd2luZG93XG4gICAqL1xuICBsb2dpbldpdGhQb3B1cChcbiAgICBvcHRpb25zPzogUG9wdXBMb2dpbk9wdGlvbnMsXG4gICAgY29uZmlnPzogUG9wdXBDb25maWdPcHRpb25zXG4gICk6IE9ic2VydmFibGU8dm9pZD4ge1xuICAgIHJldHVybiBmcm9tKFxuICAgICAgdGhpcy5hdXRoMENsaWVudC5sb2dpbldpdGhQb3B1cChvcHRpb25zLCBjb25maWcpLnRoZW4oKCkgPT4ge1xuICAgICAgICB0aGlzLmF1dGhTdGF0ZS5yZWZyZXNoKCk7XG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogYGBganNcbiAgICogbG9nb3V0KCk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBDbGVhcnMgdGhlIGFwcGxpY2F0aW9uIHNlc3Npb24gYW5kIHBlcmZvcm1zIGEgcmVkaXJlY3QgdG8gYC92Mi9sb2dvdXRgLCB1c2luZ1xuICAgKiB0aGUgcGFyYW1ldGVycyBwcm92aWRlZCBhcyBhcmd1bWVudHMsIHRvIGNsZWFyIHRoZSBBdXRoMCBzZXNzaW9uLlxuICAgKiBJZiB0aGUgYGZlZGVyYXRlZGAgb3B0aW9uIGlzIHNwZWNpZmllZCBpdCBhbHNvIGNsZWFycyB0aGUgSWRlbnRpdHkgUHJvdmlkZXIgc2Vzc2lvbi5cbiAgICogSWYgdGhlIGBsb2NhbE9ubHlgIG9wdGlvbiBpcyBzcGVjaWZpZWQsIGl0IG9ubHkgY2xlYXJzIHRoZSBhcHBsaWNhdGlvbiBzZXNzaW9uLlxuICAgKiBJdCBpcyBpbnZhbGlkIHRvIHNldCBib3RoIHRoZSBgZmVkZXJhdGVkYCBhbmQgYGxvY2FsT25seWAgb3B0aW9ucyB0byBgdHJ1ZWAsXG4gICAqIGFuZCBhbiBlcnJvciB3aWxsIGJlIHRocm93biBpZiB5b3UgZG8uXG4gICAqIFtSZWFkIG1vcmUgYWJvdXQgaG93IExvZ291dCB3b3JrcyBhdCBBdXRoMF0oaHR0cHM6Ly9hdXRoMC5jb20vZG9jcy9sb2dvdXQpLlxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgbG9nb3V0IG9wdGlvbnNcbiAgICovXG4gIGxvZ291dChvcHRpb25zPzogTG9nb3V0T3B0aW9ucyk6IHZvaWQge1xuICAgIGNvbnN0IGxvZ291dCA9IHRoaXMuYXV0aDBDbGllbnQubG9nb3V0KG9wdGlvbnMpIHx8IG9mKG51bGwpO1xuXG4gICAgZnJvbShsb2dvdXQpLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICBpZiAob3B0aW9ucz8ubG9jYWxPbmx5KSB7XG4gICAgICAgIHRoaXMuYXV0aFN0YXRlLnJlZnJlc2goKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaGVzIGEgbmV3IGFjY2VzcyB0b2tlbiBhbmQgcmV0dXJucyB0aGUgcmVzcG9uc2UgZnJvbSB0aGUgL29hdXRoL3Rva2VuIGVuZHBvaW50LCBvbWl0dGluZyB0aGUgcmVmcmVzaCB0b2tlbi5cbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMgVGhlIG9wdGlvbnMgZm9yIGNvbmZpZ3VyaW5nIHRoZSB0b2tlbiBmZXRjaC5cbiAgICovXG4gIGdldEFjY2Vzc1Rva2VuU2lsZW50bHkoXG4gICAgb3B0aW9uczogR2V0VG9rZW5TaWxlbnRseU9wdGlvbnMgJiB7IGRldGFpbGVkUmVzcG9uc2U6IHRydWUgfVxuICApOiBPYnNlcnZhYmxlPEdldFRva2VuU2lsZW50bHlWZXJib3NlUmVzcG9uc2U+O1xuXG4gIC8qKlxuICAgKiBGZXRjaGVzIGEgbmV3IGFjY2VzcyB0b2tlbiBhbmQgcmV0dXJucyBpdC5cbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMgVGhlIG9wdGlvbnMgZm9yIGNvbmZpZ3VyaW5nIHRoZSB0b2tlbiBmZXRjaC5cbiAgICovXG4gIGdldEFjY2Vzc1Rva2VuU2lsZW50bHkob3B0aW9ucz86IEdldFRva2VuU2lsZW50bHlPcHRpb25zKTogT2JzZXJ2YWJsZTxzdHJpbmc+O1xuXG4gIC8qKlxuICAgKiBgYGBqc1xuICAgKiBnZXRBY2Nlc3NUb2tlblNpbGVudGx5KG9wdGlvbnMpLnN1YnNjcmliZSh0b2tlbiA9PiAuLi4pXG4gICAqIGBgYFxuICAgKlxuICAgKiBJZiB0aGVyZSdzIGEgdmFsaWQgdG9rZW4gc3RvcmVkLCByZXR1cm4gaXQuIE90aGVyd2lzZSwgb3BlbnMgYW5cbiAgICogaWZyYW1lIHdpdGggdGhlIGAvYXV0aG9yaXplYCBVUkwgdXNpbmcgdGhlIHBhcmFtZXRlcnMgcHJvdmlkZWRcbiAgICogYXMgYXJndW1lbnRzLiBSYW5kb20gYW5kIHNlY3VyZSBgc3RhdGVgIGFuZCBgbm9uY2VgIHBhcmFtZXRlcnNcbiAgICogd2lsbCBiZSBhdXRvLWdlbmVyYXRlZC4gSWYgdGhlIHJlc3BvbnNlIGlzIHN1Y2Nlc3NmdWwsIHJlc3VsdHNcbiAgICogd2lsbCBiZSB2YWxpZCBhY2NvcmRpbmcgdG8gdGhlaXIgZXhwaXJhdGlvbiB0aW1lcy5cbiAgICpcbiAgICogSWYgcmVmcmVzaCB0b2tlbnMgYXJlIHVzZWQsIHRoZSB0b2tlbiBlbmRwb2ludCBpcyBjYWxsZWQgZGlyZWN0bHkgd2l0aCB0aGVcbiAgICogJ3JlZnJlc2hfdG9rZW4nIGdyYW50LiBJZiBubyByZWZyZXNoIHRva2VuIGlzIGF2YWlsYWJsZSB0byBtYWtlIHRoaXMgY2FsbCxcbiAgICogdGhlIFNESyBmYWxscyBiYWNrIHRvIHVzaW5nIGFuIGlmcmFtZSB0byB0aGUgJy9hdXRob3JpemUnIFVSTC5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgbWF5IHVzZSBhIHdlYiB3b3JrZXIgdG8gcGVyZm9ybSB0aGUgdG9rZW4gY2FsbCBpZiB0aGUgaW4tbWVtb3J5XG4gICAqIGNhY2hlIGlzIHVzZWQuXG4gICAqXG4gICAqIElmIGFuIGBhdWRpZW5jZWAgdmFsdWUgaXMgZ2l2ZW4gdG8gdGhpcyBmdW5jdGlvbiwgdGhlIFNESyBhbHdheXMgZmFsbHNcbiAgICogYmFjayB0byB1c2luZyBhbiBpZnJhbWUgdG8gbWFrZSB0aGUgdG9rZW4gZXhjaGFuZ2UuXG4gICAqXG4gICAqIE5vdGUgdGhhdCBpbiBhbGwgY2FzZXMsIGZhbGxpbmcgYmFjayB0byBhbiBpZnJhbWUgcmVxdWlyZXMgYWNjZXNzIHRvXG4gICAqIHRoZSBgYXV0aDBgIGNvb2tpZSwgYW5kIHRodXMgd2lsbCBub3Qgd29yayBpbiBicm93c2VycyB0aGF0IGJsb2NrIHRoaXJkLXBhcnR5XG4gICAqIGNvb2tpZXMgYnkgZGVmYXVsdCAoU2FmYXJpLCBCcmF2ZSwgZXRjKS5cbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMgVGhlIG9wdGlvbnMgZm9yIGNvbmZpZ3VyaW5nIHRoZSB0b2tlbiBmZXRjaC5cbiAgICovXG4gIGdldEFjY2Vzc1Rva2VuU2lsZW50bHkoXG4gICAgb3B0aW9uczogR2V0VG9rZW5TaWxlbnRseU9wdGlvbnMgPSB7fVxuICApOiBPYnNlcnZhYmxlPHN0cmluZyB8IEdldFRva2VuU2lsZW50bHlWZXJib3NlUmVzcG9uc2U+IHtcbiAgICByZXR1cm4gb2YodGhpcy5hdXRoMENsaWVudCkucGlwZShcbiAgICAgIGNvbmNhdE1hcCgoY2xpZW50KSA9PlxuICAgICAgICBvcHRpb25zLmRldGFpbGVkUmVzcG9uc2UgPT09IHRydWVcbiAgICAgICAgICA/IGNsaWVudC5nZXRUb2tlblNpbGVudGx5KHsgLi4ub3B0aW9ucywgZGV0YWlsZWRSZXNwb25zZTogdHJ1ZSB9KVxuICAgICAgICAgIDogY2xpZW50LmdldFRva2VuU2lsZW50bHkob3B0aW9ucylcbiAgICAgICksXG4gICAgICB0YXAoKHRva2VuKSA9PlxuICAgICAgICB0aGlzLmF1dGhTdGF0ZS5zZXRBY2Nlc3NUb2tlbihcbiAgICAgICAgICB0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnID8gdG9rZW4gOiB0b2tlbi5hY2Nlc3NfdG9rZW5cbiAgICAgICAgKVxuICAgICAgKSxcbiAgICAgIGNhdGNoRXJyb3IoKGVycm9yKSA9PiB7XG4gICAgICAgIHRoaXMuYXV0aFN0YXRlLnNldEVycm9yKGVycm9yKTtcbiAgICAgICAgdGhpcy5hdXRoU3RhdGUucmVmcmVzaCgpO1xuICAgICAgICByZXR1cm4gdGhyb3dFcnJvcihlcnJvcik7XG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogYGBganNcbiAgICogZ2V0VG9rZW5XaXRoUG9wdXAob3B0aW9ucykuc3Vic2NyaWJlKHRva2VuID0+IC4uLilcbiAgICogYGBgXG4gICAqXG4gICAqIEdldCBhbiBhY2Nlc3MgdG9rZW4gaW50ZXJhY3RpdmVseS5cbiAgICpcbiAgICogT3BlbnMgYSBwb3B1cCB3aXRoIHRoZSBgL2F1dGhvcml6ZWAgVVJMIHVzaW5nIHRoZSBwYXJhbWV0ZXJzXG4gICAqIHByb3ZpZGVkIGFzIGFyZ3VtZW50cy4gUmFuZG9tIGFuZCBzZWN1cmUgYHN0YXRlYCBhbmQgYG5vbmNlYFxuICAgKiBwYXJhbWV0ZXJzIHdpbGwgYmUgYXV0by1nZW5lcmF0ZWQuIElmIHRoZSByZXNwb25zZSBpcyBzdWNjZXNzZnVsLFxuICAgKiByZXN1bHRzIHdpbGwgYmUgdmFsaWQgYWNjb3JkaW5nIHRvIHRoZWlyIGV4cGlyYXRpb24gdGltZXMuXG4gICAqL1xuICBnZXRBY2Nlc3NUb2tlbldpdGhQb3B1cChcbiAgICBvcHRpb25zPzogR2V0VG9rZW5XaXRoUG9wdXBPcHRpb25zXG4gICk6IE9ic2VydmFibGU8c3RyaW5nPiB7XG4gICAgcmV0dXJuIG9mKHRoaXMuYXV0aDBDbGllbnQpLnBpcGUoXG4gICAgICBjb25jYXRNYXAoKGNsaWVudCkgPT4gY2xpZW50LmdldFRva2VuV2l0aFBvcHVwKG9wdGlvbnMpKSxcbiAgICAgIHRhcCgodG9rZW4pID0+IHRoaXMuYXV0aFN0YXRlLnNldEFjY2Vzc1Rva2VuKHRva2VuKSksXG4gICAgICBjYXRjaEVycm9yKChlcnJvcikgPT4ge1xuICAgICAgICB0aGlzLmF1dGhTdGF0ZS5zZXRFcnJvcihlcnJvcik7XG4gICAgICAgIHRoaXMuYXV0aFN0YXRlLnJlZnJlc2goKTtcbiAgICAgICAgcmV0dXJuIHRocm93RXJyb3IoZXJyb3IpO1xuICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIGBgYGpzXG4gICAqIGhhbmRsZVJlZGlyZWN0Q2FsbGJhY2sodXJsKS5zdWJzY3JpYmUocmVzdWx0ID0+IC4uLilcbiAgICogYGBgXG4gICAqXG4gICAqIEFmdGVyIHRoZSBicm93c2VyIHJlZGlyZWN0cyBiYWNrIHRvIHRoZSBjYWxsYmFjayBwYWdlLFxuICAgKiBjYWxsIGBoYW5kbGVSZWRpcmVjdENhbGxiYWNrYCB0byBoYW5kbGUgc3VjY2VzcyBhbmQgZXJyb3JcbiAgICogcmVzcG9uc2VzIGZyb20gQXV0aDAuIElmIHRoZSByZXNwb25zZSBpcyBzdWNjZXNzZnVsLCByZXN1bHRzXG4gICAqIHdpbGwgYmUgdmFsaWQgYWNjb3JkaW5nIHRvIHRoZWlyIGV4cGlyYXRpb24gdGltZXMuXG4gICAqXG4gICAqIENhbGxpbmcgdGhpcyBtZXRob2QgYWxzbyByZWZyZXNoZXMgdGhlIGF1dGhlbnRpY2F0aW9uIGFuZCB1c2VyIHN0YXRlcy5cbiAgICpcbiAgICogQHBhcmFtIHVybCBUaGUgVVJMIHRvIHRoYXQgc2hvdWxkIGJlIHVzZWQgdG8gcmV0cmlldmUgdGhlIGBzdGF0ZWAgYW5kIGBjb2RlYCB2YWx1ZXMuIERlZmF1bHRzIHRvIGB3aW5kb3cubG9jYXRpb24uaHJlZmAgaWYgbm90IGdpdmVuLlxuICAgKi9cbiAgaGFuZGxlUmVkaXJlY3RDYWxsYmFjayh1cmw/OiBzdHJpbmcpOiBPYnNlcnZhYmxlPFJlZGlyZWN0TG9naW5SZXN1bHQ8VEFwcFN0YXRlPj4ge1xuICAgIHJldHVybiBkZWZlcigoKSA9PiB0aGlzLmF1dGgwQ2xpZW50LmhhbmRsZVJlZGlyZWN0Q2FsbGJhY2s8VEFwcFN0YXRlPih1cmwpKS5waXBlKFxuICAgICAgd2l0aExhdGVzdEZyb20odGhpcy5hdXRoU3RhdGUuaXNMb2FkaW5nJCksXG4gICAgICB0YXAoKFtyZXN1bHQsIGlzTG9hZGluZ10pID0+IHtcbiAgICAgICAgaWYgKCFpc0xvYWRpbmcpIHtcbiAgICAgICAgICB0aGlzLmF1dGhTdGF0ZS5yZWZyZXNoKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBwU3RhdGUgPSByZXN1bHQ/LmFwcFN0YXRlO1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBhcHBTdGF0ZT8udGFyZ2V0ID8/ICcvJztcblxuICAgICAgICBpZiAoYXBwU3RhdGUpIHtcbiAgICAgICAgICB0aGlzLmFwcFN0YXRlU3ViamVjdCQubmV4dChhcHBTdGF0ZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm5hdmlnYXRvci5uYXZpZ2F0ZUJ5VXJsKHRhcmdldCk7XG4gICAgICB9KSxcbiAgICAgIG1hcCgoW3Jlc3VsdF0pID0+IHJlc3VsdClcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIGBgYGpzXG4gICAqIGJ1aWxkQXV0aG9yaXplVXJsKCkuc3Vic2NyaWJlKHVybCA9PiAuLi4pXG4gICAqIGBgYFxuICAgKlxuICAgKiBCdWlsZHMgYW4gYC9hdXRob3JpemVgIFVSTCBmb3IgbG9naW5XaXRoUmVkaXJlY3QgdXNpbmcgdGhlIHBhcmFtZXRlcnNcbiAgICogcHJvdmlkZWQgYXMgYXJndW1lbnRzLiBSYW5kb20gYW5kIHNlY3VyZSBgc3RhdGVgIGFuZCBgbm9uY2VgXG4gICAqIHBhcmFtZXRlcnMgd2lsbCBiZSBhdXRvLWdlbmVyYXRlZC5cbiAgICogQHBhcmFtIG9wdGlvbnMgVGhlIG9wdGlvbnNcbiAgICogQHJldHVybnMgQSBVUkwgdG8gdGhlIGF1dGhvcml6ZSBlbmRwb2ludFxuICAgKi9cbiAgYnVpbGRBdXRob3JpemVVcmwob3B0aW9ucz86IFJlZGlyZWN0TG9naW5PcHRpb25zKTogT2JzZXJ2YWJsZTxzdHJpbmc+IHtcbiAgICByZXR1cm4gZGVmZXIoKCkgPT4gdGhpcy5hdXRoMENsaWVudC5idWlsZEF1dGhvcml6ZVVybChvcHRpb25zKSk7XG4gIH1cblxuICAvKipcbiAgICogYGBganNcbiAgICogYnVpbGRMb2dvdXRVcmwoKS5zdWJzY3JpYmUodXJsID0+IC4uLilcbiAgICogYGBgXG4gICAqIEJ1aWxkcyBhIFVSTCB0byB0aGUgbG9nb3V0IGVuZHBvaW50LlxuICAgKlxuICAgKiBAcGFyYW0gb3B0aW9ucyBUaGUgb3B0aW9ucyB1c2VkIHRvIGNvbmZpZ3VyZSB0aGUgcGFyYW1ldGVycyB0aGF0IGFwcGVhciBpbiB0aGUgbG9nb3V0IGVuZHBvaW50IFVSTC5cbiAgICogQHJldHVybnMgYSBVUkwgdG8gdGhlIGxvZ291dCBlbmRwb2ludCB1c2luZyB0aGUgcGFyYW1ldGVycyBwcm92aWRlZCBhcyBhcmd1bWVudHMuXG4gICAqL1xuICBidWlsZExvZ291dFVybChvcHRpb25zPzogTG9nb3V0VXJsT3B0aW9ucyk6IE9ic2VydmFibGU8c3RyaW5nPiB7XG4gICAgcmV0dXJuIG9mKHRoaXMuYXV0aDBDbGllbnQuYnVpbGRMb2dvdXRVcmwob3B0aW9ucykpO1xuICB9XG5cbiAgcHJpdmF0ZSBzaG91bGRIYW5kbGVDYWxsYmFjaygpOiBPYnNlcnZhYmxlPGJvb2xlYW4+IHtcbiAgICByZXR1cm4gb2YobG9jYXRpb24uc2VhcmNoKS5waXBlKFxuICAgICAgbWFwKChzZWFyY2gpID0+IHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAoc2VhcmNoLmluY2x1ZGVzKCdjb2RlPScpIHx8IHNlYXJjaC5pbmNsdWRlcygnZXJyb3I9JykpICYmXG4gICAgICAgICAgc2VhcmNoLmluY2x1ZGVzKCdzdGF0ZT0nKSAmJlxuICAgICAgICAgICF0aGlzLmNvbmZpZ0ZhY3RvcnkuZ2V0KCkuc2tpcFJlZGlyZWN0Q2FsbGJhY2tcbiAgICAgICAgKTtcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxufVxuIl19